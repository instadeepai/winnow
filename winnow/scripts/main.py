from dataclasses import dataclass
from enum import Enum
import logging
from pathlib import Path

import yaml

import typer
from typing_extensions import Annotated

from winnow.datasets.calibration_dataset import RESIDUE_MASSES, CalibrationDataset
from winnow.calibration.calibrator import ProbabilityCalibrator
from winnow.calibration.calibration_features import (
    PrositFeatures,
    MassErrorFeature,
    RetentionTimeFeature,
    ChimericFeatures,
    BeamFeatures,
)
from winnow.fdr.bayes import EmpiricalBayesFDRControl
from winnow.fdr.database_grounded import DatabaseGroundedFDRControl

SEED = 42
MZ_TOLERANCE = 0.02
HIDDEN_DIM = 10
TRAIN_FRACTION = 0.1


class DataSource(Enum):
    """Source of a dataset to be used for calibration."""

    winnow = "winnow"
    instanovo = "instanovo"
    pointnovo = "pointnovo"
    mztab = "mztab"


@dataclass
class WinnowDatasetConfig:
    """Config for calibration datasets saved through `winnow`."""

    data_dir: Path


@dataclass
class InstaNovoDatasetConfig:
    """Config for calibration datasets generated by InstaNovo."""

    beam_predictions_path: Path
    spectrum_path: Path
    predictions_path: Path


@dataclass
class MZTabDatasetConfig:
    """Config for calibration datasets saved in MZTab format."""

    labelled_path: Path
    mgf_path: Path
    predictions_path: Path


@dataclass
class PointNovoDatasetConfig:
    """Config for calibration datasets generated by PointNovo."""

    mgf_path: Path
    predictions_path: Path


class FDRMethod(Enum):
    """FDR estimation method."""

    database = "database-ground"
    winnow = "winnow"


logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.addHandler(logging.StreamHandler())

app = typer.Typer(
    name="winnow",
    help="""
    Confidence calibration and FDR estimation for de novo peptide sequencing.
    """,
)


def load_dataset(
    data_source: DataSource, dataset_config_path: Path
) -> CalibrationDataset:
    """Load PSM dataset into a `CalibrationDataset` object.

    Args:
        data_source (DataSource): The source of the dataset
        dataset_config_path (Path): Path to a `.yaml` file containing arguments
                                    for the load method for the data source.

    Raises:
        TypeError: If `data_source` is not one of the supported data sources

    Returns:
        CalibrationDataset: A calibration dataset
    """
    with open(dataset_config_path) as dataset_config_file:
        if data_source is DataSource.winnow:
            winnow_dataset_config = WinnowDatasetConfig(
                **yaml.safe_load(dataset_config_file)
            )
            dataset = CalibrationDataset.load(
                data_dir=Path(winnow_dataset_config.data_dir)
            )
        elif data_source is DataSource.instanovo:
            instanovo_dataset_config = InstaNovoDatasetConfig(
                **yaml.safe_load(dataset_config_file)
            )
            dataset = CalibrationDataset.from_predictions_csv(
                beam_predictions_path=Path(
                    instanovo_dataset_config.beam_predictions_path
                ),
                spectrum_path=Path(instanovo_dataset_config.spectrum_path),
                predictions_path=Path(instanovo_dataset_config.predictions_path),
            )
        elif data_source is DataSource.mztab:
            mztab_dataset_config = MZTabDatasetConfig(
                **yaml.safe_load(dataset_config_file)
            )
            dataset = CalibrationDataset.from_predictions_mztab(
                labelled_path=Path(mztab_dataset_config.labelled_path),
                mgf_path=Path(mztab_dataset_config.mgf_path),
                predictions_path=Path(mztab_dataset_config.predictions_path),
            )
        elif data_source is DataSource.pointnovo:
            pointnovo_dataset_config = PointNovoDatasetConfig(
                **yaml.safe_load(dataset_config_file)
            )
            dataset = CalibrationDataset.from_pointnovo_predictions(
                mgf_path=Path(pointnovo_dataset_config.mgf_path),
                predictions_path=Path(pointnovo_dataset_config.predictions_path),
            )
        else:
            raise TypeError(
                f"Data source was {data_source}. Only 'instanovo', 'mztab' and 'pointnovo' are supported."
            )
    return dataset


def filter_dataset(dataset: CalibrationDataset) -> CalibrationDataset:
    """Filter out rows whose predictions are empty or contain unsupported PTMs.

    Args:
        dataset (CalibrationDataset): The dataset to be filtered

    Returns:
        CalibrationDataset: The filtered dataset
    """
    filtered_dataset = (
        dataset.filter_entries(
            metadata_predicate=lambda row: not isinstance(row["prediction"], list),
        )
        .filter_entries(
            metadata_predicate=lambda row: "N(+.98)" in row["prediction"],
        )
        .filter_entries(
            metadata_predicate=lambda row: "Q(+.98)" in row["prediction"],
        )
        .filter_entries(metadata_predicate=lambda row: not row["prediction"])
    )
    return filtered_dataset


@app.command(
    name="calibrate", help="Fit a calibration model and perform predictions on file."
)
def calibrate(
    calibration_data_source: Annotated[
        DataSource, typer.Option(help="The type of PSM dataset to be calibrated.")
    ],
    calibration_dataset_config_path: Annotated[
        Path,
        typer.Option(
            help="The path to the config with the specification of the calibration dataset."
        ),
    ],
    prediction_data_source: Annotated[
        DataSource, typer.Option(help="The type of PSM dataset to be predicted on.")
    ],
    prediction_dataset_config_path: Annotated[
        Path,
        typer.Option(
            help="The path to the config with the specification of the dataset to be predicted on."
        ),
    ],
    output_path: Annotated[Path, typer.Option(help="The path to write the output to.")],
) -> None:
    """Fit the calibration model and predict on a new dataset.

    Args:
        calibration_data_source (Annotated[ DataSource, typer.Option, optional): The type of PSM dataset to be calibrated.
        calibration_dataset_config_path (Annotated[ Path, typer.Option, optional): The path to the config with the specification of the calibration dataset.
        prediction_data_source (Annotated[ DataSource, typer.Option, optional): The type of PSM dataset to be predicted on.
        prediction_dataset_config_path (Annotated[ Path, typer.Option, optional): The path to the config with the specification of the dataset to be predicted on.
        output_path (Annotated[Path, typer.Option, optional): The path to write the output to.
    """
    # -- Load dataset
    calibration_dataset = load_dataset(
        data_source=calibration_data_source,
        dataset_config_path=calibration_dataset_config_path,
    )
    filtered_calibration_dataset = filter_dataset(dataset=calibration_dataset)

    prediction_dataset = load_dataset(
        data_source=prediction_data_source,
        dataset_config_path=prediction_dataset_config_path,
    )
    filtered_prediction_dataset = filter_dataset(dataset=prediction_dataset)

    # -- Initialize calibrator
    logger.info("Initializing calibrator.")
    calibrator = ProbabilityCalibrator(SEED)

    logger.info("Adding features to calibrator.")
    calibrator.add_feature(MassErrorFeature(residue_masses=RESIDUE_MASSES))
    calibrator.add_feature(PrositFeatures(mz_tolerance=MZ_TOLERANCE))
    calibrator.add_feature(
        RetentionTimeFeature(hidden_dim=HIDDEN_DIM, train_fraction=TRAIN_FRACTION)
    )
    calibrator.add_feature(ChimericFeatures(mz_tolerance=MZ_TOLERANCE))
    calibrator.add_feature(BeamFeatures())

    # -- Fit calibrator
    logger.info("Calibrating scores.")
    calibrator.fit(filtered_calibration_dataset)

    # -- Predict
    logger.info("Calibrate inputs")
    calibrator.predict(filtered_prediction_dataset)

    # -- Write output
    if output_path:
        filtered_prediction_dataset.save(data_dir=output_path)


@app.command(
    name="estimate", help="Fit FDR estimator and filter results to target FDR."
)
def estimate(
    method: Annotated[
        FDRMethod, typer.Option(help="Method to use for FDR estimation.")
    ],
    fdr_threshold: Annotated[
        float,
        typer.Option(
            help="The target FDR threshold (e.g. 0.01 for 1%, 0.05 for 5% etc.)"
        ),
    ],
    calibrated_data_source: Annotated[
        DataSource, typer.Option(help="The type of PSM dataset to be calibrated.")
    ],
    calibrated_dataset_config_path: Annotated[
        Path,
        typer.Option(
            help="The path to the config with the specification of the dataset."
        ),
    ],
    confidence_column: Annotated[
        str, typer.Option(help="Name of the column with confidence scores.")
    ],
    output_path: Annotated[
        Path,
        typer.Option(
            help="The path to the config with the specification of the dataset."
        ),
    ],
) -> None:
    """Estimate FDR and filter for a threshold.

    Args:
        method (Annotated[ FDRMethod, typer.Option, optional): Method to use for FDR estimation.
        fdr_threshold (Annotated[ float, typer.Option, optional): The target FDR threshold (e.g. 0.01 for 1%, 0.05 for 5% etc.).
        calibrated_data_source (Annotated[ DataSource, typer.Option, optional): The type of PSM dataset to be calibrated.
        calibrated_dataset_config_path (Annotated[ Path, typer.Option, optional): The path to the config with the specification of the dataset.
        confidence_column (Annotated[ str, typer.Option, optional): Name of the column with confidence scores.
        output_path (Annotated[ Path, typer.Option, optional): The path to the config with the specification of the dataset.
    """
    # -- Load dataset
    calibrated_dataset = load_dataset(
        data_source=calibrated_data_source,
        dataset_config_path=calibrated_dataset_config_path,
    )

    # -- Initialize estimator
    if method is FDRMethod.database:
        database_fdr_control = DatabaseGroundedFDRControl(
            confidence_feature=confidence_column
        )
        database_fdr_control.fit(
            dataset=calibrated_dataset.metadata,
            residue_masses=RESIDUE_MASSES,
        )
        confidence_cutoff = database_fdr_control.get_confidence_cutoff(
            threshold=fdr_threshold
        )
    elif method is FDRMethod.winnow:
        mixture_fdr_control = EmpiricalBayesFDRControl()
        mixture_fdr_control.fit(dataset=calibrated_dataset.metadata[confidence_column])
        confidence_cutoff = mixture_fdr_control.get_confidence_cutoff(
            threshold=fdr_threshold
        )

    # -- Filter data
    output_data = calibrated_dataset.metadata
    output_data = output_data[output_data[confidence_column] >= confidence_cutoff]

    # -- Write output
    output_data.to_csv(output_path)
